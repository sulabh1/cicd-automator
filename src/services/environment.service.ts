import { Injectable } from '@nestjs/common';
import { ExternalService } from '../interfaces/config.interface';

@Injectable()
export class EnvironmentService {
  generateEnvironmentVariablesBlock(services: ExternalService[]): string {
    if (!services || services.length === 0) {
      return '';
    }

    let envBlock = '\n  environment {\n';

    const allEnvVars = new Set<string>();

    for (const service of services) {
      for (const envVar of service.envVariables) {
        if (!allEnvVars.has(envVar.key)) {
          allEnvVars.add(envVar.key);

          if (envVar.isSecret) {
            // Secrets should be loaded from Jenkins credentials
            envBlock += `    ${
              envVar.key
            } = credentials('${this.getCredentialId(envVar.key)}')\n`;
          } else {
            // Non-secrets can be direct values or from .env
            envBlock += `    ${envVar.key} = '\${env.${envVar.key} ?: ""}'\n`;
          }
        }
      }
    }

    envBlock += '  }\n';
    return envBlock;
  }

  generateCredentialsSetupGuide(services: ExternalService[]): string {
    if (!services || services.length === 0) {
      return '';
    }

    let guide = `\n╔════════════════════════════════════════════════════════════════╗
║           EXTERNAL SERVICES CREDENTIALS                        ║
╚════════════════════════════════════════════════════════════════╝\n\n`;

    for (const service of services) {
      guide += `\n## ${service.name.toUpperCase()} (${service.service})\n\n`;

      const secretVars = service.envVariables.filter((v) => v.isSecret);
      const nonSecretVars = service.envVariables.filter((v) => !v.isSecret);

      if (secretVars.length > 0) {
        guide += `**Secret Credentials (Store in Jenkins):**\n\n`;

        for (const envVar of secretVars) {
          guide += `   - ID: ${this.getCredentialId(envVar.key)}\n`;
          guide += `     Type: Secret text\n`;
          guide += `     Description: ${envVar.description}\n`;
          guide += `     Environment Variable: ${envVar.key}\n\n`;
        }
      }

      if (nonSecretVars.length > 0) {
        guide += `**Non-Secret Configuration:**\n\n`;

        for (const envVar of nonSecretVars) {
          guide += `   - ${envVar.key}: ${envVar.description}\n`;
        }
        guide += `\n   These can be stored in Jenkins as environment variables or in a .env file.\n\n`;
      }
    }

    guide += `\n╔════════════════════════════════════════════════════════════════╗
║                    SETUP INSTRUCTIONS                          ║
╚════════════════════════════════════════════════════════════════╝\n\n`;

    guide += `1. Go to Jenkins → Manage Jenkins → Manage Credentials\n`;
    guide += `2. Select "Global credentials (unrestricted)"\n`;
    guide += `3. Click "Add Credentials"\n`;
    guide += `4. For each secret above:\n`;
    guide += `   - Kind: Secret text\n`;
    guide += `   - Scope: Global\n`;
    guide += `   - Secret: [Your actual secret value]\n`;
    guide += `   - ID: [Use the ID specified above]\n`;
    guide += `   - Description: [Use the description above]\n\n`;

    return guide;
  }

  generateDockerEnvironmentVariables(services: ExternalService[]): string {
    if (!services || services.length === 0) {
      return '';
    }

    let dockerEnv = '';

    for (const service of services) {
      for (const envVar of service.envVariables) {
        dockerEnv += `          --env ${envVar.key}="\${${envVar.key}}" \\\n`;
      }
    }

    return dockerEnv;
  }

  generateEnvFileTemplate(services: ExternalService[]): string {
    if (!services || services.length === 0) {
      return '';
    }

    let envFile = `# Environment Variables Template
# Generated by Jenkins Generator
# Copy this to .env and fill in your values\n\n`;

    for (const service of services) {
      envFile += `# ${service.name} (${service.service})\n`;

      for (const envVar of service.envVariables) {
        if (envVar.isSecret) {
          envFile += `${envVar.key}=your_${envVar.key.toLowerCase()}_here  # ${
            envVar.description
          }\n`;
        } else {
          envFile += `${envVar.key}=  # ${envVar.description}\n`;
        }
      }

      envFile += '\n';
    }

    return envFile;
  }

  generateReadmeServicesSection(services: ExternalService[]): string {
    if (!services || services.length === 0) {
      return '';
    }

    let readme = `\n## External Services Configuration\n\n`;
    readme += `This application uses the following external services:\n\n`;

    for (const service of services) {
      readme += `### ${service.name}\n`;
      readme += `- **Type**: ${service.type}\n`;
      readme += `- **Service**: ${service.service}\n`;
      readme += `- **Environment Variables**:\n`;

      for (const envVar of service.envVariables) {
        const secretLabel = envVar.isSecret ? ' (Secret)' : '';
        readme += `  - \`${envVar.key}\`${secretLabel}: ${envVar.description}\n`;
      }

      readme += '\n';
    }

    readme += `### Setup Instructions\n\n`;
    readme += `1. Copy \`.env.template\` to \`.env\`\n`;
    readme += `2. Fill in all required environment variables\n`;
    readme += `3. For Jenkins deployment, configure credentials in Jenkins as specified in \`CREDENTIALS_SETUP.md\`\n`;
    readme += `4. Never commit \`.env\` file to version control\n\n`;

    return readme;
  }

  private getCredentialId(envVarKey: string): string {
    return envVarKey.toLowerCase().replace(/_/g, '-');
  }

  generateKubernetesSecrets(services: ExternalService[]): string {
    if (!services || services.length === 0) {
      return '';
    }

    let yaml = `# Kubernetes Secrets Template
# Generate base64 values: echo -n "your-value" | base64

apiVersion: v1
kind: Secret
metadata:
  name: app-secrets
type: Opaque
data:\n`;

    for (const service of services) {
      for (const envVar of service.envVariables) {
        if (envVar.isSecret) {
          yaml += `  ${envVar.key}: <base64-encoded-value>  # ${envVar.description}\n`;
        }
      }
    }

    return yaml;
  }
}
