import { Injectable } from '@nestjs/common';
import { CICDConfig } from '../interfaces/config.interface';
import { CloudProviderService } from './cloud-provider.service';
import { NotificationService } from './notification.service';
import { SecurityService } from './security.service';

@Injectable()
export class JenkinsFileService {
  constructor(
    private readonly cloudProvider: CloudProviderService,
    private readonly notificationService: NotificationService,
    private readonly securityService: SecurityService,
  ) {}

  generateJenkinsfile(config: CICDConfig): string {
    const { project, cloud, notifications, jenkinsConfig } = config;
    const dockerImageName = `${project.projectName
      .toLowerCase()
      .replace(/\s+/g, '-')}`;
    const dockerImageTag = '${BUILD_NUMBER}';

    const notificationFunctions =
      this.notificationService.generateNotificationScript(notifications);
    const deploymentScript = this.cloudProvider.generateDeploymentScript(
      cloud,
      dockerImageName,
    );
    const credentialsEnv =
      this.cloudProvider.generateCredentialsEnvironmentVariables(cloud);

    const jenkinsfile = `// Auto-generated Jenkins Pipeline
// Generated by Auto-CICD Generator
// Project: ${project.projectName}
// Cloud Provider: ${cloud.provider}
// Generated on: ${new Date().toISOString()}

pipeline {
  agent {
    label '${jenkinsConfig.agentLabel}'
  }

  options {
    timeout(time: ${jenkinsConfig.timeout}, unit: 'MINUTES')
    buildDiscarder(logRotator(numToKeepStr: '10'))
    timestamps()
    disableConcurrentBuilds()
  }

  ${credentialsEnv}

  stages {
    stage('Checkout') {
      steps {
        script {
          echo "Checking out code from repository..."
          checkout([
            $class: 'GitSCM',
            branches: [[name: '*/${project.branch}']],
            userRemoteConfigs: [[
              url: '${project.repository}',
              credentialsId: 'git-credentials'
            ]]
          ])
          echo "Code checked out successfully"
        }
      }
    }

    stage('Install Dependencies') {
      steps {
        script {
          echo "Installing dependencies..."
          ${project.language === 'javascript' ? 'sh "npm ci"' : 'sh "npm ci"'}
          echo "Dependencies installed successfully"
        }
      }
    }

${
  project.runTests && project.testCommand
    ? this.generateTestStage(project.testCommand, jenkinsConfig.retryCount)
    : ''
}

    stage('Build') {
      steps {
        script {
          echo "Building application..."
          ${
            project.buildCommand
              ? `sh "${project.buildCommand}"`
              : '// No build command specified'
          }
          echo "Build completed successfully"
        }
      }
    }

    stage('Docker Build') {
      steps {
        script {
          echo "Building Docker image..."
          def dockerImage = "${dockerImageName}:${dockerImageTag}"
          
          ${
            project.hasDockerfile
              ? `sh "docker build -t \${dockerImage} -f ${project.dockerfilePath} ."`
              : `error("Dockerfile not found. Please ensure Dockerfile exists in the project.")`
          }
          
          env.DOCKER_IMAGE = dockerImage
          echo "Docker image built: \${dockerImage}"
        }
      }
    }

    stage('Push Docker Image') {
      steps {
        script {
          echo "Pushing Docker image to registry..."
          
          withCredentials([
            usernamePassword(
              credentialsId: 'docker-registry-credentials',
              usernameVariable: 'DOCKER_USERNAME',
              passwordVariable: 'DOCKER_PASSWORD'
            )
          ]) {
            sh '''
              echo "\${DOCKER_PASSWORD}" | docker login -u "\${DOCKER_USERNAME}" --password-stdin
              docker tag \${DOCKER_IMAGE} \${DOCKER_USERNAME}/\${DOCKER_IMAGE}
              docker push \${DOCKER_USERNAME}/\${DOCKER_IMAGE}
              docker logout
            '''
          }
          
          // Update DOCKER_IMAGE to include registry
          env.DOCKER_IMAGE = "\${DOCKER_USERNAME}/${dockerImageName}:${dockerImageTag}"
          echo "Docker image pushed successfully"
        }
      }
    }

    stage('Deploy to ${cloud.provider.toUpperCase()}') {
      steps {
        script {
          echo "Deploying to ${cloud.provider.toUpperCase()}..."
          
          retry(${jenkinsConfig.retryCount}) {
            sh '''
              ${deploymentScript}
            '''
          }
          
          echo "Deployment to ${cloud.provider.toUpperCase()} completed successfully"
        }
      }
    }

    stage('Health Check') {
      steps {
        script {
          echo "Performing health check..."
          sleep(time: 30, unit: 'SECONDS')
          
          def healthCheckPassed = false
          def maxRetries = 5
          def retryCount = 0
          
          while (!healthCheckPassed && retryCount < maxRetries) {
            try {
              // This is a placeholder - you'll need to customize based on your deployment
              sh 'echo "Health check endpoint: ${
                cloud.deploymentConfig.healthCheckPath
              }"'
              healthCheckPassed = true
              echo "Health check passed"
            } catch (Exception e) {
              retryCount++
              echo "Health check failed. Attempt \${retryCount}/\${maxRetries}"
              sleep(time: 10, unit: 'SECONDS')
            }
          }
          
          if (!healthCheckPassed) {
            error("Health check failed after \${maxRetries} attempts")
          }
        }
      }
    }

    stage('Cleanup') {
      steps {
        script {
          echo "Cleaning up old Docker images..."
          sh """
            docker image prune -f
            docker container prune -f
          """
          echo "Cleanup completed"
        }
      }
    }
  }

  ${this.notificationService.generatePostStageNotifications()}
}

// Notification Functions
${notificationFunctions}
`;

    return jenkinsfile;
  }

  private generateTestStage(testCommand: string, retryCount: number): string {
    return `
    stage('Run Tests') {
      steps {
        script {
          echo "Running tests..."
          retry(${retryCount}) {
            sh "${testCommand}"
          }
          echo "Tests completed successfully"
        }
      }
      post {
        always {
          // Publish test results if available
          junit(testResults: '**/test-results/*.xml', allowEmptyResults: true)
        }
      }
    }
`;
  }

  generateCredentialsSetupGuide(config: CICDConfig): string {
    const { cloud, notifications } = config;

    let guide = `
╔════════════════════════════════════════════════════════════════╗
║           JENKINS CREDENTIALS SETUP GUIDE                      ║
╚════════════════════════════════════════════════════════════════╝

Please configure the following credentials in Jenkins:
(Manage Jenkins → Manage Credentials → Global Credentials)

1. GIT CREDENTIALS
   ID: git-credentials
   Type: Username with password
   Scope: Global
   Description: Git repository credentials

2. DOCKER REGISTRY CREDENTIALS
   ID: docker-registry-credentials
   Type: Username with password
   Scope: Global
   Description: Docker Hub or private registry credentials

`;

    switch (cloud.provider) {
      case 'aws':
        guide += `
3. AWS CREDENTIALS
   - ID: aws-access-key-id
     Type: Secret text
     Secret: ${this.securityService.maskSensitiveData(
       cloud.credentials['accessKeyId'],
     )}
   
   - ID: aws-secret-access-key
     Type: Secret text
     Secret: [Your AWS Secret Access Key]
`;
        break;

      case 'azure':
        guide += `
3. AZURE CREDENTIALS
   - ID: azure-subscription-id
     Type: Secret text
     Secret: ${this.securityService.maskSensitiveData(
       cloud.credentials['subscriptionId'],
     )}
   
   - ID: azure-client-id
     Type: Secret text
     Secret: ${this.securityService.maskSensitiveData(
       cloud.credentials['clientId'],
     )}
   
   - ID: azure-client-secret
     Type: Secret text
     Secret: [Your Azure Client Secret]
   
   - ID: azure-tenant-id
     Type: Secret text
     Secret: ${this.securityService.maskSensitiveData(
       cloud.credentials['tenantId'],
     )}
`;
        break;

      case 'gcp':
        guide += `
3. GCP CREDENTIALS
   - ID: gcp-project-id
     Type: Secret text
     Secret: ${cloud.credentials['projectId']}
   
   - ID: gcp-key-file
     Type: Secret file
     File: Upload your GCP service account key JSON file
`;
        break;

      case 'digitalocean':
        guide += `
3. DIGITALOCEAN CREDENTIALS
   - ID: do-api-token
     Type: Secret text
     Secret: [Your DigitalOcean API Token]
`;
        break;
    }

    guide += `
4. NOTIFICATION CREDENTIALS (if applicable)
   Email notifications are configured automatically.
   For webhook-based notifications, ensure the URLs are accessible.

╔════════════════════════════════════════════════════════════════╗
║                    SECURITY REMINDERS                          ║
╚════════════════════════════════════════════════════════════════╝

⚠️  NEVER commit credentials to version control
⚠️  Use Jenkins credential storage for all sensitive data
⚠️  Rotate credentials regularly
⚠️  Use least-privilege access principles
⚠️  Enable audit logging in Jenkins
⚠️  Regularly review and remove unused credentials

`;

    return guide;
  }

  generateReadme(config: CICDConfig): string {
    const { project, cloud } = config;

    return `# ${project.projectName} - CI/CD Pipeline

## Auto-generated CI/CD Configuration

This Jenkins pipeline was automatically generated by Auto-CICD Generator.

### Project Information
- **Project Name:** ${project.projectName}
- **Project Type:** ${project.projectType}
- **Language:** ${project.language}
- **Repository:** ${project.repository}
- **Branch:** ${project.branch}

### Cloud Deployment
- **Provider:** ${cloud.provider.toUpperCase()}
- **Region:** ${cloud.region}
- **Instance Type:** ${cloud.instanceType}

### Pipeline Stages
1. **Checkout** - Clone repository
2. **Install Dependencies** - Install npm packages
${
  project.runTests ? '3. **Run Tests** - Execute test suite\n' : ''
}4. **Build** - Build application
5. **Docker Build** - Create Docker image
6. **Push Docker Image** - Push to Docker registry
7. **Deploy** - Deploy to ${cloud.provider.toUpperCase()}
8. **Health Check** - Verify deployment
9. **Cleanup** - Remove old images

### Setup Instructions

1. **Install Required Jenkins Plugins:**
   - Docker Pipeline
   - Git
   - Email Extension
   - Pipeline
   - Credentials Binding
   - Blue Ocean (optional, for better UI)

2. **Configure Credentials:**
   See CREDENTIALS_SETUP.md for detailed instructions.

3. **Create Jenkins Pipeline Job:**
   - New Item → Pipeline
   - Configure Git repository
   - Point to Jenkinsfile in repository root
   - Save and run

4. **Verify Deployment:**
   - Monitor pipeline execution
   - Check email notifications
   - Verify application is running in ${cloud.provider.toUpperCase()}

### Customization

To modify the pipeline:
1. Edit the Jenkinsfile in your repository root
2. Commit and push changes
3. Jenkins will automatically use the updated pipeline

### Troubleshooting

- **Build Fails:** Check Jenkins console output
- **Deployment Fails:** Verify cloud credentials
- **Docker Issues:** Ensure Docker is installed on Jenkins agent
- **Notification Issues:** Verify webhook URLs and email configuration

### Support

For issues or questions, refer to:
- Jenkins Documentation: https://www.jenkins.io/doc/
- ${cloud.provider.toUpperCase()} Documentation
- Docker Documentation: https://docs.docker.com/

---
Generated on: ${new Date().toISOString()}
`;
  }
}
